gAAAAABfUyyp_P74wDAr6zBlEJbmw1c4A3oEOOpEDhngTM_BXBC1GM1BAVgHRszYF5h4RfxefRSoo36swqqvzWlzXsnnAlfnA2ksB_n_i8WGHl3UxqWPxRFi4ckxkA6hJ6LcYt1G_5REvihv_4cJhqyOKf_ihY6cxuDDV8tVFWjBYjgGsjuGX4Ulnm5xXgfL7UEZipHQ92Pz31cLJfGXQBJkTga8CZZ83iMtP6mwqlT3kqkywohNu-OBnRaVVfZHXVHQjWQne_XJGDDso32Gvy1QxxE5b33vCPFyK_kSvWvrD98WmFqn0fzTZsV9DVNp3tOgcPcnaylFDbSI7EBStsqRNbpQ-irx-iB3_t35bxvfj5IiHXJTdDZDBVOBBKm5bo4IIgLfnajeamCutVAierqtTTm2LcPLstOW7mDE13np_-wetOrUDk2LoIE20M9SL1-77NWqfI4KJloXD3ecDrpCYxEU57cO43EYS6-9X1exOU0kTn2_e9m4doRc6Z4Z1iB0DsghdOZdE5VuEvtQ0wjY5JqVTp8m7NSFauoFDV4VmYxAEea16yrhqnaL7Sm2boRbx7osepD8SXwduB8Osuouk795JJXF41tguf_nxuzKcGNbreSubNLDm0-u_-eyAbnFbRGLZkPrB1jQNtzSdX1ekmmGN56xWSp2wRCZ4tGdAgfaux0kDLku_AU-U1MVNj99Jf7WgnHPUT7CK5kLb999_8VZbK9rG1qLWUGw7ZrofGBEtCT7gEqPEQ3KWiB8ehfKmgUbEibTb20P_SqCWCy4TMOSW4Gbi5mJhyPdNiEFbWgbYlosiLeytDY0u0EWQRzQyaJW4J1pnRoyozVXdsjICAfBUWiekgSqXfHQ27xnx5qyQJztTO9qLJ2uXb14qc6KJqlZd7I2dGTF5uP4yW0FaMgxbKSuq1aGp7rcXunw0AXzpq9rAALy081iPe574lmevPdZWsEz6BbGVw9btbu5XGc4v9KUFDDIb0uXKK78lqw9k_HYLR2MFqdYBCkGtMqCcK2_9XMMBDXiY5dsHGBGILttJHZycvr1QqdQwVx2PA26UlZbaYcfjUARcCWkBJtCcIme-_k1rwwAl_2rKnHfLbv4DDguZvmgGLVNRzpFgrr7pM6KgJqqMhFfq8Q24QDc7hIrFAkVr9xrp4PKkLnRpay33HPBUMWvGMeg6vVhkCTRcTCcoKMCfUVlCOsJY2JBVSHwFQIo1ixhIs5APXFwEMWfY2jDcDH_uhpyasjwpwGKNoyupy9rcXBqHYTHwEpUd_z9cidhtJ6qCjckkIM_7g3-vmuKI7sm0zrmKzQoLQ6nF5Oqagf4KIFwW8eJCWmlU3JmpaQxiRUwum4xBrMldi4PuSUQdslY5CH2r5r3qqgrFFjy0PArvJyFql4ucxz46V-T6P7bdTXtXi42fTF1KTPle6lPHpnqwm_jXY2TWYzujOLewOzqc-6GbDsvMYbDOuUnWpiWOLNk-GzzoypYlRqu9ri3nWCN83z7OupTnurOQtIH38UF5XywGCMO0H5NMQ9IwO7rDRFNniSMX-KMCGBI3c5JmIZROv9IxuJDulmUobfPeeos2cszfRH_dOI_3zqMI-Yyn8eFhuPnuO35qB-X5gFlgOoJiwBuuEUtPqPTuVquFQZFApiU1wyvdcWsKsrIbFSG23BIvtTWEw9bSE4RcCPYuNtD2Dic9JdGG-KXpb6sBeDtyBcr280vWRnyA3O7ey5uP4oLhdY9WYz-E8mlzebmwq0EWifmWojtAW9LyuwC5lnQCg3kJ9nMrd1mMzpMuAxSlKKw0QHP_RbqmdxsjH3u0DeAQ7dOvqw9P6QloanoUjqQBCgqQyG9H2st-eYdXK8sMCwL2HPHhdbwLeqK6Ol92eET2vAL08gxa6lkDhvhdQNzIcr_zdI68AAQTc5eHsUaMLSP_IV6pCcaMNanuyYKgdqFzTrdNb3ErV_UzgqQH_FmQdAoq95Ep_2bXHHYjArpYhBSut2DEr5Is7FzSpjABBvkty9GxR7XkXZ6Q2nP0M7rDB24iiMPQn6qpQlxhJh0klfAYMp4H8QQLDhzSnyhJtR9qxxN5DszltTeQCkm6UPY_A3pzliFJozwTe35676uKArGsOgWKswmjM4NTNbfWZaQTBb9MpA4vQC3m8VWNLKJ5SKSPi5Vrx_KE-iSFnDPi4sbtx1C5_SKv_haP0zUZLnzmsnz_ZFnlxHTa0KM_i7P2Poa0sDOwHRyYqYSTTbzFz3C9YlIyoSgm_WAGIG8F1bi1s1uIr2Uo15cT4xxU1v4aaIaIvIMidaOHxyWCT6aKAMibi3W9TYb7IR8jnvVOnfeDb5uAeBNbGi2ne3M1-pesfHThxx0wALm-f4DbDEUFGB6JCrVHsaqx7EwTbTXPOCgmm001BcmI4OPM35nZRhGCqVkQ16C3DNvymxale2WMpAz_jSgK9vU6Ygsp9NTPZi6KP_roStrV6y_kecwSlSWJW84LCRzrfWpmZH9twSMHe_319mknTsMt3z6PhwvCk0c-9XuK1-s-uB3PnJieVyGWE2fC8_2s5wgSWfVuwyoYlaYTmfIE6ko6-_IQv2A8Ipdrc0QX6l44n7AmR-h7R4vwW2VF7TS5s8WIfCKmuYDSYKQKpzJWPpScBjR4dQvf6qL-eQM3cYqslkOrTNM2QaO2vHY1EWber9AJ9hMlQUdPsbw6O_uTXunSl6ZfV0IcjcbNlPj3z6Di-IfOA3kSt17UY_5fUaPxj-dfkhwLmLGQvAa2_wOVLFtXSP-l7lvNkPUVXbNa1XZhIwLiK1WFUvf8X00WEvCtf6TaiAx6DJ-_leFaB8-3qduwTLdZAcPRpiXLPmtv8SGe7PTBdFGT9lMYDndPnjjpkgcybzqOZ-NTKs6R5SoXcIpQWMsEOIyyYsFwaJJbhOjE7sdVxVJQNa0mbgcV-xkpcRXs-mt-W5-3JtblmBnWxf8B10lK1-CvEo1muCivP4lDiYnPZ341HL5bFmsfWqs4nYA7CPO6e9zzjcteV2AAdYBstaCibOeJBdkxUD3HCn79ufiBsH2PsktwNDQ1K2Fpk-c7h7cA2y58NKkOm0Dc7_ivNt255oUiMjMpVmVqcShjiDxI2spuSDAJDJZ85l8P_pUnyLkKk48-K_upm62pOqMljk0B-E4g-9UGJmMQv66U2eQqM6FgkzX5MSt9G6RAKb_Q38HuTICndMZRiCMpqGbgLJeGisanRg7HWnTUbFpB35FWYgk2MYotEHKsAH7Fy2kLMyRKG7wTQwjNOHsUXUBuH3AO_9vVw6pxACG9R5xlfTfVsLt9dEy3AfB9REbeLsw3KpyfaSZpMvXWNMB0CeCZUDa9xP-U3lAlOA1tcAa1s9qJ_h31F2TUqqD5AsP_xV5YqpWcAs8-Oqjua3nGeEPBGoGCs9nme0aWL2wL2gvHRlPpP58q8uSbWoQWPl-n7mZmGY5G4qFVnr9wx6y_Hxsg3Mj4dgkjb8pbNSckw7mJHFTxMAHOyL6mlzMqe3EDBbwJhjpDKjz6q5WAKhe-CcGpMgiTR5F5vCWX9hLcagvdv-Tj_yTcr0i5DUt1ZOEi03ECZg8T0vxZsIMSmRytzEEDCDMUd3Z3HaAV3E2TooIDjfi3tCM8YEL4qtlBY1GKHPLqGnt3RhR_EZrPqLhADcHisZMkxGpq4FquvKgelC65JqDlYvKlTSLqGyND5NuPpx1b_OcdAnmewpdyZ9Jgvyz8WM3f1iH4u8as_7sAqYPi3IbP2iDi2nQtiLkMcpyuj1m4qRXsPskE8UxM7ukN-9JdUA2DRBBJvJuKsIMH3aKp2hnEsrZ3BAE5JlpnJzVzAYqgZ6aqqCoSwqLXafFrFEp7BF3bcJh6AYrPCEHJ2Dc8KHy8HET5LAo2-9F5QSgp5nKaIOHpmMJn-wnaTp7SgTZZ2H1BW9BCt3DzZI673KsnytWl6YTR4diTFK1NGDMMNCxlYiwasCOTZekCzRzDEOYbdU_YIA2ilCdj_OQlu7N6DOAOinJVu0YNnYX3VsUhh3BD3__L0MKsa3QzvmpfoG0cAyJf-eu85nCV-WkjsyvnacLxViN4KyaoGwNmVVYJQ_j3bJSRAQ_X1LMABq7N0cQqRqMzl6QW91I_267iAqLEJ-6fPUBUKUiEMdSaPb9iXKei0ciBLCf1yh6g-PmO6gAHAGt0jERf0JErIsaNZKwzO-6ioX8dkgCLT3GNi8XDsQg581hV9q9VBNJ1TvmmZIyZZMqPEJMH3sFlJDqlXv6vtKxOSJMbsJDDLS9hmhekstMqYTHwTFwUFyknETCjFMtjsSURVQnfHXU4lrFAurylkgcxHuOkU9oILr72KqKkjYIGQL8ERoartahUPwfhUCs77-2BF9x6gN5v5t3NCI89gwZ4OOl_nKq0DyEDrmMRNBMuCQbv4hjmJEiLgksBZhxlQ6JWxiSnRmfYiBqHgFNT0_MWUlcG2hyNrpcByVsE_Hb5GJTm-Qc5nsUpQqjhwlg4GrBIrAC-xjpXVQSiiW_tQNTDrpRjXmW6q-qj7NJOGWcunJxmXBFNHIq3Y3hR22Q2Y73cF-dCK2syvcRxtJTw6qHyQK5op0QzRQ8SthYS9i5eTpdnQJrFaMW5KnnSo1EUrXdCiVUMZrb1AaOltF5LPyf6gQYprKsHq4J3E4DDHIskLOcEZEzS3B2j_x5UTg2VsDhkgIUpwSuIADpuuOxwhDtw08gJyayPM-sFQt11uJ1XtuqVAXJyEDEKZNL5x3MmYbbZWd-Rby4KK8ZqdnwFk3v2Y4wgBAi5CfK-n-lS-UuhbgbP0cy11bsufMblZ2yddWrTzB9DsD8H6qsdA3ooVR0twUNlKXABi1-g8vKjCnETL3sft1NeEfw-YJ7oSIUtopwbu68xf6bmFxGTgC3vdxMAo1Kt4tfOCkU8MXgCUv8Udmf1VmQbTw0MdQK5l60RHyDAosd2PoVvmkfncfVfT8Z4M1ksARtd7v5GfTUxg-hXinYLvnMt5HGrm0rl3nxE15m-sb6CB3l5M48EDjG53dRzbHPPWRLAT2U5-fyIxgQIUOXbNlkteFO0tVbJ4GbTeO6If6kXcjuYbaWlYMPwTsPMk2qrl_xbkT7FPy3PaZ3vDB05Yv26F0Fk92mkJjA57RszTWQ4fTHa8jsJkRQMNjVUyqd_txcSaZuZyezsXiDdJ6jKmlObm6ffyPfihw2c6WxEelaxjCt8LfMcI_e6UjN0qVvzABtDlXlCLcEZGOPT4rMNmPwjZwXeMHFWl31y7bkNoPtS_2pwKx0t0A87iRw0hU__ylUwo7U8iwgB4Zgn0oJhR6mMRU8XJFLdq8RqDt8CAW4lRDp4ZpEYbg7EPphymUA3cicN0spPM4OXqSPjUw377EW2XU9iH3VJuWgeee7kOI_Muqko5Ht4plOqD3OQT2780LHIgcjCOBFFD3XJWMdaymUZ1R3mNkrF3s1er9dad-n2Ak5ULiw6YJdSdcMIyAEYavhG2pB2CfzL9nYJj2pABUEti4EoMrsfJ7QSYRBKcUuuSH9fcIRzSt-zj1Dr608QIy3afOQ1umZN_GfFXp1aLRGfmsbIzz0Eya0XI0YilN6O85hy7-pCpkDScIxGdL2ENMBcyeg6At1SSzc6jyLKO8pXeDFZGJ3zX-shSFx7DaXop2mVLPL_BVbAsY_I3lgCRaF7TC7ewr-BfI1WLCcFleYMx_3hOAzEUDU2iy4Uopm52t8ozv6gK2LpnVx23h2Wti_TKWESN0s-Umqm_o1PWzO4vVyiCU0YfibH-sbHwXm6k3DCmC97Waac-FBcVo4mo4aMdx9EqCKKaphsYwbf_LM2lBAtSbqleQ1l9izgusLnHTLU0zEINGZrwL_vwnu4kmedlbZBT6dVvPFVu_slCWIP-Qo58tyxdHq6NO44fFDg34tHrOke-jIRSzTrokt8o1LDSYTtqLCi1J0YdUWmYhfMHgVEPpuGE2Xj2TNjARx_JJeVRv0tL6rPk26LsKNLTWIaYCE41wXJeTv6WutEnkh71buunl9StR7qWKsgkoOJ2nKR0wx3V-rkY3OPY7QMYL_13AEbaldCtGb61egne2VLnAIHZJ03AyDz1zItDTxgdcKCNyBueldUtCwrGsDlCxXCYbaLmN9WHrDI2P56r2A4m_oSzt0KO2ZL9BT1fQjTBERgtXvZ5Rvy8cIXU7IEa5Tl1Qjv6t5VKq12VMkl8nK_v5Ejm6A9Le3Lb5DLpYK7F5FlabJP7e7f-Q9X0868VMM7YTlyxjSQ2qRHh1DWr2EIou4F79y8s7zwYwj3x4SWQQG6OUFRBqAFQTkE49RlMuWzAKCJn69WH7tHFdpF1FHJ6YDHkkl3q2aufKyG0lPCW-EYIIOQkjflvwpOHiTTt10uqtS-cYaxU8kh9qs_YBfQAFveuq3ULLjUonHgDmqr274jYTQ0XmCnuh1jw-b-nktqSssDYJ8aSMErX0a3pEhfDxWn0ZY4x1i5qQj-1SkOCoklH7LoZVLIGBPBmmkao3Koxu-YxDSJleloopX3MkmCzjwiRpKn9ndWYFP46VVP_1R1M63QZBkPw8-7IKrma8D-gFkGushfOY1P1GQnZKfiljlWRHuOf3V7uxfwhqsn6Q-WTL4WARH7ZgdnAC6-4x1ojTDp0bi3zYfdxGESH8Nrl5_k6p7N2pnrWx90WuB_LUYzpqa4vlY6Nd1emjp-KAO2mbo-Qk_o1XwixqWiNDVHDmj-6Mb4JnvbzY8-u0GZ3KlEFtBb814iNf_2QTzRn6vsRTfdLfN-rtdct_eKEI58XTXJAnfo3NJNvdZ93ILL1iWrMHacdmcDVNXoFzefKiH0ReiM0enI7wRSuYktEUKHndeXGinsuMy6t0Ah0wnOSJgZwoa5QajNE6mwc6zuUwYvA5MG1gEuriTNZiM1tfVbeFLr62sXAwo3ONk5s6Nt5ycq6TRU886Y5dl34aw-6zF9mIeANpV9JpzPb12-enDqPPJGnolUfP3zFCC1ms_LR4Oi0w4PNYUEBP-d5Hyn8JoZwsmlmT9gxNG6ayK4D-uCsE53YPRS1nK3eBZiapuDhaiQ7FZloPCHi4ZfI5UmPQ_84dxgX7SSAs-gk02GvrHuNLE-l0nA2GnhTf1uVDwodF2vhpTEoNHJFo3N_ta88YAUnperJ28b-On8Gmn0knGsv7y7Dm2Fz8BDXKLLpD-MoSckRZcVM5pgYGpOp4X_SE1ouNmPsxQtBQfeUM_BPTqUnxw1YXlEcV_SSBJnlAUP1ia6OC_OT0gmTPeCYOvstp5Wg3jlLWkX9ZN0ikRXETluqjzhB73haFOjEvyfDwFRFzc68NV-uD3GVvhC1uvAEtuKAisfbGD3k3Ru00lbBbHYpwulqNRdWflWZ4n8Fg6JjmsORgwDO7Y95QUaBAFF3jt9nwHHC6OOh4XVYCLcFs6yaUZYoPu-XdToOmwlEVdGOP6ukVo5S0S8VMNJCSKmTP5mpebfnZRUGrBjlEhWQqzKj3gCyeJRavxQaDy_o3CZxMs3o7Oex6vhI3g7oDGRb-teSd52VZx8GrSokDL7u1iFGNmxoUNwxrfqXgFwlNQq49yShF02coVD4DV3tc6NFIpT1vXXow-OEQsvTbRVTdvZId8zIYZQc1JE9HEyryEiMXRTEarGIAj2HWzfAcfW-gPBliw2fukZRf836qFNfaeJdCZA3fuoeQqQBnOHB4NlllKyzCgG0OyaxkIRvNs_l9BNo4-PKKdR5DxFdqTWn_7ueVVs3f80iyitsSdCydLCIyts4LGfAd8FIMez-8_oQHP6v7PyCubJBE-v3fcwuGjnSg7aJASzwj69AdbHLE9fqQSdclyN2gBvIJGcjcfGPYZpU3GzPkBBRppUAtujTV7y2kuMXKvKCcz8LcanoiuzXrN74QC84LDBHHJoQ8ho9KHukEcqFiM2AweQOAMv74NxHMqoyjQV_ntVpa3Mrr4_ek97xb0It0g0mdiphoi6X4LdRKPxlbpuLRSDaYqQ0WWXkbZlpiRr1kpf6jO8BWgOsRwOSEKnfVa02MIYdHR6xvzYoda0bIaUZQrgBq11yhAuqBpwi4UvU5DBgLpOuN5x_iOYjzYwPzTWHdUV7uim8f12MhUURLALFSLkN1IZBuXkX_YOqOlugRc03EUz7VVLH7b2vzJgN_HnOYPlkaT9lutPe5HCSwQ1vggslCace8ObAFx4ekLcBTk3efksZR_yokSjbdJflMvp2EWQxfa1o34pqMClfV8l60tBONpQMtT6jXO9Z_VzTQ4z3bfp9zAwuGb0aCaG6zRenOmwLP1cqrIihw181-sXn42cU32mheMJO5Xfm9AcIBi_oA4QxDJr6mFnYG_qLFHybAZFlueSC7HALLKgpj0ej2RblCf-GBXmttUNEiQjw1y40MgSa6AaB_qlJVCAq2xOZGa0_QN7EzIdzZ1KuFG2FO-NbEu9A5gG3nNEezJjb5uJRtXSefv3Hx735CngGn_NB1ghimszM3nFcm2ZDAlkbKdFDnb31SdSOZNKi0TOuwvNfhHKDW1dn6uJDHh9z4sdl8IiToo1BuKjJBjdt498JhX5yJ1RsX10fm7GxQtUl2OdcpVwJUcj-FPPFp9LOzG55Vy4isijxQyVqD7l5lfRSClOsEvHujO_5k37wLpLlc2RDysQaEjbL4kj0R2ZYyBVk1wz37SwQT3lW_o0uMffUuBiibT1rIaSwh11Whp9WpS9QZ_tmje3eFrxGEXB26j0flh8N9wZAv6sZkI3yWzgmgQXemO9BReyWBj4jkQox2KLGuRhLlEsA4CbAliIOQzS2MDIkyxWrdcx9fvHEIeYK-nWpSEd3tFA7cRawCPbpq1vZ6hzwqjkX5p0p1Xnb46mvYTRbRX0afWLK35Z6Pog9ewe9wfyQtJBn6jyKkKDe71lSkShqqP8ad1_wzCWXrNmX98n8i02ZvFdmApBOLKAXSKsTa_dNg9ZMTArjTtnOKwLe-Wc4xCqvXnTkMJ0y3aWKRoE7zVs3t-WrWC5ydcMy7oPpLlioHV1nggukGmt_ohe2VOEt4oZ2so0i65f2ycP6bQt1YqWHNLMi2Hnr7GccyhSP6mMGF7UvTl5wOC32PeEGYnFDbXzo8d7YoApPS9QkovhB3sni9E00pqeGryGTwSC0FYfdzaS3Zhm2vltxLxbE0B1oxFfxIR0SqQACAR9GxGQY-LgeN9brdWC_hHrH017SRM41XxmNGI8FI4Jtr--pX8pPYHFRA0iwzAneuJ_LuZL2h4NCgll0n80N8ic1InbLkaCrIeee28gcrTrrEY0fD_8PrUPvmUIniZE7X-CBNMht8jqLp24C2DsjGe8mcr7CPolIkYX5TVXojQJLX2lG7727VUWTzhBSqyQZRDRYnkf8K90Vk47sjU7uWCqrX3uLNaH3lbbsluI4y-6QxV5dt-rlt1HiSgz00nXOgIMZzh2dzXNsuCUsFuazBK-msrP8YGcoJkpzj0y3KWzVSKAbRfAz5m4qa4iLDpjcye3qUArWveoT6tP-MsSDRiAm5j8qj2gJKhdQf8ow78-XjUZbv5FuVYdZlfFKoVDS-dP9gMDkXvRjmvFEFS_vPrFLjI5ccYA1RF_fWw6GtscMx-3yHu2ouwGb4dFOUv1YkzBZkUScsoLtnKF0HLAVYB0jQUZIJPPfktaAi8s5DDELnEJMlkIt5jrN5SP8JpsXKLbf5Cv5CdIMjVWyskevGnahrylLCmszEE2lzwGLcTOT8i-MmyAXOSTK4e_Bgp_w4akfgKGJbnIS3i-HABhaCxowofI5Gyv7_NKy4XD4lGALcxh7PNV02dkHQIAOXMhFs95f5rfkb0McwF8EUp1eeMn8vkp6pLvCt3czKWvT2zYL8mpsYmOPFxn3pZns2scK7dHD6H3QO0CaZhMMiCtBkP81ESyNcRPeL50OPAxQNbGAHolJsO_UyFaQpj81sRmV1Vu8KC-T8MR3-C88Ai7Vj1Mf241jv_1LXa94CIrlvRtukpdYQe6V_jUM5OpzbRz_O7CdpLrpBpyryk17vmQiu3w8X1h0B6wjdSxneDqxUA30Ta3iun0CFVlxqVVqsET9e3YsxKq1rFiNTVF0icGoHlTSjUUIwkoAbbeakDj8OqXgrIGdufYFfn1mMc0Kc51aPJ7oCjThi8e1ghJCvGo7x0RdH4W2PNDtvzsvjJQnH9wHJenix3py3qRZ2dvrLKq_J53nlG2eS4kbemDGRB2NjPOlIkJvvTofIe13Avfrz3VLXVlbxX4ZwgxHjVUQ-16m72dbLkJvaCPlwx1MFrGAtz-iwIjC5Hy-JcxpsttWaxxU0FFG2tpEo9nTQy4NZMuhpRJuIBquJBeHqE0miOxp0CaNj3xfmS-CAPBVYklBe-K31o57j0K3EHp4YGSAndx51h1OD_1G2FtSGoz8MzpcJO-FAYfY6t2j54a-ZWRe0wRzQ2NETZdam6kYjzZqZJGEQph_73XsBT5bFgShMg1NrIXK478NaEbzc-RdgGtdgZAGMSnP0UpQ97Ap986sSnkhqtwyg6VN6F52-rdvouGYDJDBCMJijIgO1lIRge3y8ffxz4tCaXNVgJ3lpk7ThwQsRv93FJ6hWzdAKCx6M3vzTRvBfu1W473wxiHaXTUiJ9saRBPpmhqI33caxypWRZUf_-ZnOeSRkEzblvB4c9sRhZQfjwWNoocK9D8jeZnnpXPXvUzNel-qbRseO3KOzS9dub9rA6EwEBMbvnuOxc2z6hklL7KBbt0_VcAUX1BNmrCE_U71JotJGqMc4A5RSCUs2vyEL7MLNCf0gr3gAO42OBz03qPzGGhztdhBVi7mdH19qxq3vvXLwj_5TWAZDCXH2D5_CGKhsnDD7vHjinlF_DKG62Hx1piKMikmPIEOiIrNZfhiLg_CzVxT6L2RHmhzg3Qs_xFtv1qB9bogwEJVv7YvI1pt4kqbrpS8P26rnDf5og7tWqh6e-jaE_mgm0SwKGno_TbVQAeGWJ1dbCln4OxjBP9m0vaqnFwmQYL9VprT3XqaYKnL3_Qm3Duhqb6Lw4Q-UbxjqRa2__2H5eXxXrsqEdDIVyrSjcE39N6t-k-alKBEEBCcVouDH2hBeeT-TQ0HTakUp4ObYMgdSQvIxkZ82Z2rFWJLwha_JUFWirmKimILv9vjj1BQ1pCndqjgZf6dn5rGuHr7OxPaiakkzikTJbBs70VF82xi38whqLKPVfGmNGwWiNxaLofDibax4eqKqLbOAdaO00hj56U-4d5fNY4RqGGkEp_X8cVkYrfDyvAm2XIhNZIGRCsra_Dkp9jnFfF5aWCVdGsTnOqR1G36tnHlW7LqiCdsHZU5ga8n1XSsbMJ9JE4wybwtl4YyK9KOMT8kHMQMHZsAGAaDEpYV6aj0LkNcgkR4diaFaQ-Crf6giETRFG_yJnzfo54nGj5BHE-Zww2i8N8KqhVqNiIfwcqSCTelY4kSQyhfmi3SnD06ChCGOt5ZFQXVuYXSLJ7w_tp8aR0tE7x7sPMy94MzcEaO5SPNyo0mjObS_rjmoxl2_zLri3TWmK2e_wu4jtExF067Mwzb68cmVoCW9-ViyQeLmQNkSriCfofre0BcfhQhR-g_sLGPrnQWXtpclZ5IpkAzO0trgmEB5L5EcEBITjjyP9PJSjbfyn0QSZLieexQPcJnmfEaXzojROIBDILclByJrBMhnJHyNa6mzsUPmWVuwIKRHRybRQedfCHQgkMJ1uqlpHC3mJzzNo3xJiuthQCltOscrccj-byEzFOMDlL94GO9uAWHes10gUEbO-coMW2WnVKfuFMAcbrjPWbjJABaAKpj6vxgCjQdLH7eECGsSZoqUYT9RD1f9ZLv94YI7-_INZC1-k7wdmrs2qnTBN2AvL7XTOc40iuALM8dQmcb-bGHchROBBq3fgXYXptBpG5hHamg8UpJrlyNcMbj3-YQqaf6KtuEs0xhbeDrGxT1X5VHZ5I2T02-7X-M4gvmwVEfBrgnaqm8bVksR1XkQS7sqdMsxkJXk1fv1k6TywA0lrbo_DGkZHHRqqAe-AoIJn_FrIIpKE50C6dc6Rk3_MMBMomW3YQQWVadTGkN5_znwMHSj2OK01o_o1yEVe9HvAap_hdp6sV_2p8z64JotsdQAbSTuOcpgX7Kl7NAOZrpsKLqLIzachvCmf9yjuEDCfOtP2mmHJg8SYBe_LK2TT7UuO0CccEf3-QpZ99RePjGGTkjUVm3-acWHaSMuzCZ-15kWoVyj2isuD8ajzeTZUm31t_mq8RWAkDHH9bNjPsyEW_EeE_C37kQPhEEbKOcfEiox1WKfjtZHZBB1pKQu7n9T7GndO6FBwGunEBMX3vypq7-45ibRBXTMD7f21TY-zz5sYInMUwtTqtETNMG-0S-sDjRe0NKwrPdzrVGq4w8BSbbd2n9fmvGrxL94e5F-IKGKSiU4mNu1_SCo-Ya-e02QNZgjhbgi4EhowTafDllXEl9O0-zH96XvjxqFWOEiFiHzRnRUR8rCkxqe9o8lmHQYmkllTV3HOaMr8i1nSPynBrlqMSeUOmrIPF5TyNur5nr7cLDIk4QJek_mCtwa0ZLhpTSW76ud0KFXVicn3LEWzZGaw_r6Yd5MWUURtv8lySe4JLcjWKXyn-tLOD9PLpFVWxJKvJAdgPTsgRgDjHwP4NoqvPhbrPxNngX00Tf4k_q-HDwT-l29Gvok5CHJAm-tOWubE1dNr9gZEuE8hJl4FWxajS1Z2UMyPSkcqLoeY2xBXBo5w7VZnIu-nk-aIymS-nu76TAA_bIbE_LVs0KRvKe6RzEpIViROgyNp7GXC6Ttg-4RGAK-Hss-2Ra4SJ1D3s9GfBWbEgQvBGRxSucT4w8XUZzWZZq-kEzWHIBSHGNtbWP2LwWw6efnjBk5oR17iPQqFLrd6HHbX9Ai-XC4ds-IY7oRxA5lMWyoqhw3Mj1i0xdYgino8TteRgokyWsKZKC-j7VKq8oHEcApJSoQARHLd-3RFycmWrskjWBUN0P0ppxBtg26kM3w_2eLeuc8nUzOdOrb4LE_JEEioAlkD5nuDDVeri9bYBcGOrOr3x33CBa0pk2SGy8Z7rHa-jxLf7h3QYtUGLib7FLFjhc0UmKDkCrlFrC6DIl43R9gF4t-hrblpDR-jSFdvCB__pqldkoy8UbmqnIMU_k3QYXM7GrkdTyWi31WZzXlZLXAfL4d-K4enMW5JQyDPXevAisj2SBk-P1ILOH80pIeCUyyZXkmjubkaHQ3XzAKyzaw8Vq622GfFfkINopMQmFxXkEtQ0Fl9fxziAK7hgHbexJwM1s2M4Nk3BjPU38rfn-o9KIMKC_3R3OADqAXPU3gmQKXNEoodMq9OYSKoNr27diUD1OzQyeLUsARZxbkUelH5tC-spLQIX4ld_IqdDsqVOreInf9cAFQ_gejOmWjhLyfNnii9KJZtef-jP5mt5xagF8nIQ9ikaSr4aJIu9QNP3hseveviJBUZmvgmYhH-EDiMlYgr-mfi5ox-XOt4DVAMRMnDYjej4kldRTLqrCv57EpHD0f5PDCMtU8mx229WyQqJai4TbdDXTK25Go04cOi8iMX6CaZrjywdgFrG4d6q37qTdjy4PyJZzrcXZulby3Li-9BY584xqGZj-DkxEOG0lX_TgUDbS-rA55m_jvcn_FbQX9dSi2MEj-X2DovqjklwYuD5RQJi7B2O1looTY5-e2Te-HS84PrE8C-Ux4s7avOyGahSJ4QKC7_1tEVfBIw_gFL24ZC8kr47zCjwYMPzq38B0hZJqODU20iS_GbtmLEwlnAXGiYIV-6_ZRDrSiuQQuNgX62rc4MBtaYJy5u-KMo0rh6dgEfvq5P4HoS0oRRqVN57oVgvvqPzMrx9-MTosy9Kmwv22dmJi1F39OHA9xbTtg76z4Dl9MIeKMCYE3Gu3QzD1A_lbDOYM_4DL01rq5N01hiHY70jUbxxOqBRZkbjRI-H9Y8-2LFIRmwhKGBWt7DtvNw0QbTF1qT6BFwpw9R9QxylsN87Ea4NE9T4ayx8CYQvD8LzUQ6opXssDnyMHpaUoLYoI4ZxawLVz5PgcNk1TEN9AXQjq8_TRvuWSN3EGJHnWcWkquZJMYtoScztVi-P967jd6PsXzRy-u7jAcN06SZzi3neYAxJXlshZ5BxaQExxY51xfLdiUjRWLWQ4Dz0YQSxYigziMZ6n0RQQlVU71Eg9P35I41G20C1fAxIPfEa50ekZSSTsrMsJJW3T844JK_yv8Zu31kjVZd5Muzz5jEcZg45PhYyFfA_OD6KyW4QDIkVs_kKYDTWmqtL9V_1y8OrkEzPkEYPLC_DZOfUC3SPSBTOFggzN9ac4rIxEdA3WWI1bezSs89IVLnIUFa8wrJ-rJbkYR1FyViGI1wZNOl5T6tw8fsz__7yxLrzYP4D_ClgNrGR9LlWROjJOPCR055PCCCcEGw_kajuo8aO__Brl3NX-tjY3mqFNOZEX6bApQaz6EZ18gDBM0MnPAly9PZFNRm-lyTKiF4w3AbXbUtQhiMziHt5_yt6v9i7RDxxzoE3yoiaY0MZX7ZgDg4ELqgtD8FNEAZgHOdb3NQSlAE8d9u5Fwi0a-EuTyZn-5n15F2l51ZpLRm6zN3fIx_wtZB66160F2laS5AClXpKt0VahuoBNgcGYRKF9Vx1tbWQrRCeAGupms2twpLijuI2m9Hca375OFdbtdaCHebNY2x62EifXTA_U1H90zcnMLKhoDOlC8Yhu08tizQ14k3bRuPGJIcNqBzXkb5UwIm5HYoGO2BlMReE-eM-GeaTllzLrm3398Bz_eZRVhVKX2rovrAYHjoLnDBXnisjt_Qh1Fgoxah0-PCuhDvDsm2KBuZr9ivLHLYJEMQDSqDt63-GuUIP_Bm6_AHDiwODQXztHpL5v_63c2CPFkFw8I-uAc8DfF1ZqrRMjGh23B2z1TJ8Il-Qv2tc_IIqEYF-K_7jQuHO84laXz1LKKYiyg8-gcsb3X45cFzScuO_Nd9sfc8xxF-TiRw1ueldlQHsWyzare6aLxda3ufGX1J2rIUU1w7qsNLB_V9xroz0BDHZIQpfxVjp9SK_BUGFokfYmg7UAVxJzbZ4NTOy0IhqR5ZCElIwMjuEBf4CyHNEFdBfkfu3t88Z4zCAp4nW5YJZR4xA9Cg-D-FLmxoRGeh0LLWxecnLa3Sj6NX6LKuR5UZ8v3ukrsHPtTZmcZwPDRSkXiT_wGQSp2wlWbA35BECe47kPU7M5WJ4LZIt6jmSZstdLmH9WI24ZsHS_TqB9aiy6UNiy1fazfM4JI42WzrzjjBVw8cAYmNVu9Qg5Z3bu4hYKeefWWkRqw8Iy87GLqIjDPxmmUn7N6LXWbKS3pT3KldcbpySSDzjK5PlayvpjIDXebY8ms5Q8RhlXuGyG5otMbukyWVzLUx17UlidwXO9T67HxIq4J7xzagFkXc4Trmd_wg828WT95geR_IDiszNXmwSjXp5BytGnvNHe48QQm5st6IvlC7bHRm4bdeVdCxkyz1aKy30-YxUGjoewD7uJGX8LRznoMIOdxxFJk-NxJgUKOSfRwqgPfaNufqm4qwuktD63Wi01AYrdq4HKUBncKKD7jxQC_p7JJh6gs3r27G6JoCW0pR9D7IxfBLvzlHB5eNz49AJsQInTS9X9YadTpb6nNYHE7VcQd8zz_QX6BbS3udGv1JFCcY0ecsQJu-rMR7fIUGa5-eYAAGpVhAQYfbL3RCWrdSAMnbjDkDGpYAMDVdp8RcWiEkuzzJyqZRfIa1lhku3qFTaynSL2of8X8l4KVoqqnrxSqeaWxf1tXE5avzDUDzmIhCqFphKvLRiEnxzapvqL6muVAcCZ9SUN1Q2560S87jQPR9DcESfjlZMZsld2ukX6m8CxQ2IxNBHnusc96HH-ldOkSJheh0J-pxkeDxIJU3iQcHBLa8CiaweAviFlW0GYCSHVugbmniPeUotBmM3IwQxA3wgljSeR6JyT--Z7sBzdOmzG1V65lsAMTTRKwgmrzpSE1PEC7lS9Vg8dSqHvR1QhnEk49sDpUJLmmAbBrS10-ExFQ40mGPSrGbcKlFybf4Ww1YhjwTE3ABx9ofZxFF_XpvOCNk9uRH6D0ckea5bozCt96Rd4iiSfIazI3wyjvuS10UVGDr0x5G2GiVvtpmc84fvT3koZExgHsOC7Sw-0-MIJuV4ht2wv3Oq0p5rFzONQm8HSuYiguFrMatSQ5lqhNDs8t9aRT1YfTtsTI18FJyaTAO-2BguotyamqyEXERBlUzTTh1LQWSLhVSZeo6KH6IOkOYwxLRcs__1gcQh9yQwLHzOp3mv6NBJ2D9XPyCJA5nNdf5UZyvtk4JxU2U6j_a_HAbwOyWvmFQJvZTbjuzGzJBaFcWd1WWxavwXaZGviunPqCP6v-FHOSDfeoX8u3rKTFEEljC5VMIn8mmG870LtPrPAdtVB-u8L1SR58oJ-RkSlDVhIfvDBlst8u0EZCRo86ndWNT9QQ9Qfc6a63DJNxn4ubOdkl6Z8z7PVv4-6SMGhfhKrJFA7Ucw-oEMXxD7ccHAyiP11Fs05zMY5STK8DBBt85c7vIaUL39H_BXzpxiSlnqJrwb_7tpZsMftM7BfjHQ1L3D6ruCI4l9g3SFIGPn3QczaCsBksZFB5_O_aR4_w_c8guga7i8ZoAB19ZDN6g6FVwaJ2_4KOWzdLn3TsQKHv1EjyLvovwM1gKugvErbnBpFdK79HXxoEwmB1ihCXWiWqDLSK3CpJ67_G3SOP_ESeti5z5L5I9RWjvnJh6iBnxozLoGdBbVIkaIMSsoN0zmXHgru2pFVeiBapEUsZZZVvlZg8GWVXjJ-wbdO6ntax7jxEXBdjR-5aR4GZUYjCb-CSVAWKINugYpEaODU7PSyNZcBMRSAXFm8DKogbTjNkl1IJ4m3Jqv32asTv144X-yA-63uRM3XU1N7KZUR3Myn0J7yaqs8KLSqaomoZ4C9H2mCYiVLBep9URTfSigSwCLb98kwLt0QazKz2O9RTeX13oe3S6bVpIcden0ZJbiol16F6cTKyDkkF91suCx9xPtbEMJa99Ex40OUtrnQzuqdjN3fECEL8Y3E4mZJ7u4_CW5FvF1I-n9rCC9xO6WlodzkparwujCGL96tsx8_QEe71LKZ3G35rRivhqNf2nTVftO_BQBMNhwAFJT7RwfRy7kfjglUccEAxQGh-M-ebWp5YxIFBEE2XAivmXIeWeyUpsdUJ0yeQTfQ1ofi5vZlT410dhVCMCoAapgi5rnt8GREs95ptS4IeFj4wsqat6HwR2VrQB6moPCqPRmb8jxogJcvS4hcQyVWcgfG3zqoWJc1ca1EjGTgLCtqyAuzffrYoTwwR8_qxqdkU8KydHzhaBNbFfnR4DH0gGiZqPrWTRQEE-C1ZHoY5QQVIWDbJwCGMVZB0_d15emfB7VZRu1egANpH51rgERnfKeMzo0HASvlYq9iw3LCk0Dn6kytw2obl5tDpj_qE6haov-3fHs_SiGsp08H1CU9Tc_OA9YC3aHNTbtDNt_e9Od04d75zZGyU5wWYmXBOIid40QNPOGr55emiLXZJOfZcel6vR8Wzm2fM3OoKRfZHWnLQiuZTRf8NZeNoZhG4n6xSGAoYmz3uFlb5IW8DAZxncrDpdQBkUNFDPNBrTs5xmitFjPJ0ab_SOQHpwQjWdkJsPUy-0v1XmNUDVvWeUW-ghWpEMXRcdv4vexmvgi40yib-_s_Mn5-d0nJYT8oHN5pF019Zhczd3-pHR3DUgX0AaN-GBTlCSnZSxFRoqXLuEnE4JWOkJTV77h8uzoDhfBFE4Lwn5t-Zqk23W7OVTEoGXHCLaOzSzNAknnDJ3M3Ks_qUNO_u3YzfJ9ju7HMcvq86BVGCoVhGbzDe6hF0pQwMgeLnw7DMrrjYaXbmQ6coibwTf1uyqXDk6DnpCK8Z5SyA92QUdTSCVSqE2Akl94dmyE83HEgWE9H7LetS0s6KKqqtPZBXpBr1g_GIIGMyxhDnDKUj0n3Px0hSTehf1sQ--SB451lWarq4zAwLrAPFQMOEvDWdV5yWhMDApgCHDZFBQW9Wq9KAMBT4mgpgi6awNiGskLxDSniqiYsSJRFUMqx0pVRBI9HUBJ44YfpOR7nUikR0rpAThu5hSrcCfa4i2QcEBV21anqwTdgUIUXEBq66Ffs_vnbYWyqb3TaUsWXrkjF4LiRduu3OBoQAHS2ZuDgBHKKwf_wxfLXmEIFwZ9M-WmaF3cWJ1XfrhiCBey3k-jfOG6rfX7LWoRsI-ZCaC2i1hUjqB6NYme9a4I8pp-AR-x0asspoy2wvUDMqtdIG6Nw5xxAlO2YakvwTzEEbfp0RTITwmEKCSP9F10RMRJU5A3p8pvqqp4KJaZ_0kuJC3SgMAocBSV-b0kgqn4DduXBgrzC7HciC6w7BCUwfN8hIrtEkCg_3PgK3_BWXCG-w4uB7VKY_VipLLu-72OLdFN-k6ErYjYSuqlgZKDIIZ2dQLF3aRHFyGurHwAxpOhe2jNrcR4Ssu8d-Nan-qWKOhQc7S6Fo2VX3hgRLpavInJQBApWQlZN65Df8z87VO9Sbi-cToQPR5Tqwy7SGAbOUjyXFoI4D1RxDgAp_3oSO56ii8UnQ0hUcUuMHzfu7CT8eOyaCgvycFBAH7wqBlLuwvyVRYnBT35fbPQPxGQ8xMKfK9HpvBurfC3KhLgSA2Bq3au4zbae4juFly0ZahfP5FSoPrJYvo9VpdGfBOfV3UlLMMkJyVm6YS1Vt1DEqAHr6_RNTnvcHogNHMlcVBpt7abDECAukWANwReqaPOvE7ewxeBIKKfa9lReEHhnTcF3ov6yvNE55NTgNgDw3RmyaF-THWGEgCc5jpjJi7LtQ4XHpm9xe-X8uwSzmVk-7jBxCCKVb8jtm9aGyNdc7zst4yVLgRo59mksQ-6qhYbZ9EOtkKr23RNyGGmqzM_T0y4BWsb54NZgSSHUzHP-nJxvBGtIYSYUwkolH3TbHVW3amvB6PUNrEAPNK9hP8-LbIWH0jP2AJHeKi_mfleSFqvpR5cvj6P3J-YfO3i_lee-HxjRFVxHAZ9AwlsBbrVpsUkFD7vKk0spGjzdeHNdIxMr-OFuk1F9ob-0LfLOiNXIQkDZqil1iHC-3e3To53QK8rbzRmf2JzLToW-nwrUxD-cfR7JrE_uLXM99HzaNX-nTNMTksy7RPsegBqhpjiJy62JpeEOQ_MHPKPm0XWXBmtW0-0bucSf4dAxb5nRsDxuKWisNKgdQlj34O3SqqDl7QJN8AU26pFCFQ0XtDfDrsCUFFdwuh83NdV2KH6FgI5ZcomQZE3FI9F1Mkfcf1XSMCvXSSG2yOxiuMJeiLA5xg6rmyeLUiv49eNc7iHYupcwTbz3WNo8CPPxYDebps4zVl5cDplb_mEQh4m1JiIyYhI5iQ7SleCuFAzS3SXyz5Pm59Ae1eOg71_eemzX8GteZX6xzYwQxM7ivMbBZt59sRLsdUP3SS3kgYlIm-J2YQsaIccwxPDUbBm8Wq9AR-qbPF-lZOCIc60C_AM6y167YoE5Jw-OLY4AixzvyoqN6sSHpWRM--m8MH_pfziBudpb7Z-sfpYKI4cydWTXl-QnZ0_MEnf4vyfDiJOOv_ph-e0AW0BM9jL0qzN7qxgCewwlpc__LNXbBgzydY1dqaV25DbeV3_46Nm5B7HmFz7e5Gx8hFnv8drDLoYZn6U52rLihN1UCXobkJRhPe-TnHKvPJNJBfDwTH1cQgG7cZQtPcs7oEmlfnx873EO9ZNhCD1DSqlswPyZ6M6cvpmbkt6eFOovHU8xUFOiE7cL9kHj7W5Z67Hs0Fs-8BcedSK8kPU99kPUlkUjxo516uFV2MikUaHWuKj5nm6SGvYMvtt_KNu_M3P6FMU6V-iM0WH50enueHgZD4bbHaLT0XdgEjYkd8LUt2TDyanH9vGYy_MbLVG2iJTxSvGKlKwEGVKZXyWypKwOCI-fsG6ND1C0c-VJXpZTyr0J9Hr8IvYznq9wVQC9bF8csEHZXrD0cV59zHmLF-tzlQ8yU4FInpmeuHtOdazB8GqMjy4J5thcN3Zuv3Q8H5tXi4oLvLeL0H9oDs6UJK0U8zhxCUmTnrmIgIjwgZGE2D7GD-3Fd2dNLqXqnRiNZcpsveywycflga4D8cB1JQRXeDGHilB3lommTkR5j1o05QmUNuZhwMDXxgTim0xZecrZghZDUfeSnfqfGfTaDV-ZPDvAZI3GUnxfQPZo75d1qtKpUH5ijOBhawBpeWfGquYNip0I8VA210r-U=

def SelectionSortStep(array, i):

    ind = array.index(min(array[i+1:]))
    if array[i] > array[ind]:
        array[i], array[ind] = array[ind], array[i]
    return array


def BubbleSortStep(array):

    flag = True
    for i in range(len(array)-1):
        if array[i] > array[i+1]:
            array[i], array[i+1] = array[i+1], array[i]
            flag = False
    return flag


def InsertionSortStep(array, step, i):

    for i in range(i, len(array)-step, step):
        if array[i] > array[i+step]:
            array[i], array[i+step] = array[i+step], array[i]
            while array[i] < array[i-step] and i-step > -1:
                array[i], array[i-step] = array[i-step], array[i]
                i -= step
    return array


def KnuthSequence(array_size):

    i = 1
    order = []
    if array_size > 0:
        while i <= array_size:
            order.insert(0, i)
            i = i*3+1
    elif array_size == 0:
        order.append(1)
    return order


def ShellSorting(array):

    order = KnuthSequence(len(array))
    if order:
        for step in order:
            for start in range(len(array)-step):
                array = InsertionSortStep(array, step, start)
        return array


def ArrayChunk(M):

    while True:
        Ind_N = len(M)//2
        N = M[Ind_N]
        i1 = 0
        i2 = len(M)-1
        while True:
            while M[i1] < N or M[i2] > N:
                if M[i1] < N:
                    i1 += 1
                if M[i2] > N:
                    i2 -= 1
            if i1 == i2-1 and M[i1] > M[i2]:
                M[i1], M[i2] = M[i2], M[i1]
                break
            if i1 == i2 or (i1 == i2-1 and M[i1] < M[i2]):
                return Ind_N
            M[i1], M[i2] = M[i2], M[i1]
            if M[i1] is N:
                Ind_N = i1
            if M[i2] is N:
                Ind_N = i2


def QuickSort(array, left, right):

    if left is right:
        return array
    flag = True
    while flag:
        Ind_N = (left+right)//2
        N = array[Ind_N]
        i1 = left
        i2 = right
        while True:
            while array[i1] < N or array[i2] > N:
                if array[i1] < N:
                    i1 += 1
                if array[i2] > N:
                    i2 -= 1
            if i1 == i2-1 and array[i1] > array[i2]:
                array[i1], array[i2] = array[i2], array[i1]   
                break
            if i1 == i2 or (i1 == i2-1 and array[i1] < array[i2]):
                flag = False
                break
            array[i1], array[i2] = array[i2], array[i1]
            if array[i1] is N:
                Ind_N = i1
            if array[i2] is N:
                Ind_N = i2
    QuickSort(array, left, Ind_N-1)
    QuickSort(array, Ind_N+1, right)
    return array


def QuickSortTailOptimization(array, left, right):

    while left < right:
        N = array[right]
        i = left-1
        for j in range(left, right):
            if array[j] < N:
                i += 1
                array[i], array[j] = array[j], array[i]                
        array[i+1], array[right] = array[right], array[i+1]
        i += 1
        if i - left < right - i:
            QuickSortTailOptimization(array, left, i-1)
            left = i+1
        else:
            QuickSortTailOptimization(array, i+1, right)
            right = i-1


def KthOrderStatisticsStep(array, l, r, k):

    def sorting(array, left, right):

        while True:
            l = left
            r = right
            N = (l+r)//2
            pivot = array[N]
            while True:
                while array[l] < pivot or array[r] > pivot:
                    if array[l] < pivot:
                        l += 1
                    if array[r] > pivot:
                        r -= 1
                if l == r-1 and array[l] > array[r]:
                    array[l], array[r] = array[r], array[l]
                    break
                if l == r or (l == r-1 and array[l] < array[r]):
                    return N
                array[l], array[r] = array[r], array[l]
                if array[l] is pivot:
                    N = l
                if array[r] is pivot:
                    N = r
                    
    N = sorting(array, l, r)    
    if N > k:
        return [l, N-1]
    elif N < k:
        return [N+1, r]
    else:
        return [N, N]


def KthOrderStatisticsMedianMethod(array, l, r, k):

    if len(array) == 0:
        raise Exception('wrong_data!')
    if l not in range(len(array)) or r not in range(len(array)):
        raise Exception('wrong_data!')
    if l > r or k > len(array)-1:
        raise Exception('wrong_data!')
    if k > r-l:
        raise Exception('wrong_data!')    
        
    cash = []
    
    def sorting(array):

        if type(array[0]) is int:
            for i in range(len(array)-1):
                if array[i] > array[i+1]:
                    array[i], array[i+1] = array[i+1], array[i]
                    while array[i] < array[i-1] and i-1 > -1:
                        array[i], array[i-1] = array[i-1], array[i]
                        i -= 1
        if type(array[0]) is list:
            for i in range(len(array)-1):
                if array[i][len(array[i])//2] > array[i+1][len(array[i+1])//2]:
                    array[i], array[i+1] = array[i+1], array[i]
                    while array[i][len(array[i])//2] < array[i-1][len(array[i-1])//2] and i-1 > -1:
                        array[i], array[i-1] = array[i-1], array[i]
                        i -= 1
        return array 
        
    def slising(array, l, r):

        start = l
        while start < r+1:
            if (r+1)-start >= 5:
                cash.extend([sorting(array[start:start+5])])
                start += 5
            elif 2 < (r+1)-start < 5:
                cash.extend([sorting(array[start:r+1])])
                break
            else:
                while start < r+1:
                    cash.append([array[start]]) 
                    start += 1
        return cash
 
    def deleting(array):

        counter = -1
        chunk = 0
        deleted_elements = 0
        flag = False
        for i in range(len(array)):
            if counter+len(array[i]) < k:
                counter += len(array[i])
                chunk = len(array[i])
                array[i] = array[i][3:]
                chunk -= len(array[i])
                deleted_elements += chunk
                chunk = 0
            elif counter+len(array[i]) > k:
                if flag:
                    if len(array[i]) > 2:
                        array[i] = array[i][:2]
                    else:
                        array[i] = [] 
                else:
                    flag = True
                    counter += len(array[i])
            else:
                flag = True
                counter += len(array[i])
        array = sum(array, [])
        return array, deleted_elements
    
    def k_finding(result):

        place = k-result[1]
        if -1 < place < 6:
            sorted_array = sorting(result[0])
            return sorted_array[place]        
        else:
            finish = KthOrderStatisticsMedianMethod(result[0], 0, len(result[0])-1, place)
            return finish
      
    sorted_array = sorting(slising(array, l, r))
    result = deleting(sorted_array)
    value = k_finding(result)
    return value


def MergeSort(array):   

    if len(array) < 2:
        return array
    m = len(array)//2
    l = MergeSort(array[:m])
    r = MergeSort(array[m:])  
    i = j = 0
    result = []
    while i < len(l) or j < len(r): 
        if j > len(r)-1:
            result.append(l[i]) 
            i += 1
        elif i > len(l)-1: 
            result.append(r[j]) 
            j += 1
        elif l[i] < r[j]:
            result.append(l[i])
            i += 1
        else:
            result.append(r[j])
            j += 1         
    return result


class Heap:

    def __init__(self):

        self.HeapArray = []
        
    def MakeHeap(self, a, depth):

        if a == []:
            return False
        else:
            self.HeapArray = [None] * sum([2**i for i in range(depth+1)])
            for item in a:
                Heap.Add(self, item)

    def GetMax(self):

        if self.HeapArray[0] is None:
            return -1
        else:
            max_elem = self.HeapArray[0]
            index_min = len(self.HeapArray) - (self.HeapArray[::-1].index(min(filter(lambda x: type(x) is int, self.HeapArray))) + 1)
            self.HeapArray[0] = self.HeapArray[index_min]
            self.HeapArray[index_min] = None
            parent = 0
            while 2*parent+2 < len(self.HeapArray):
                if self.HeapArray[2*parent+1] and self.HeapArray[2*parent+2]:
                    if self.HeapArray[parent] <= max(self.HeapArray[2*parent+1], self.HeapArray[2*parent+2]):
                        child = self.HeapArray.index(max(self.HeapArray[2*parent+1], self.HeapArray[2*parent+2]), parent+1, len(self.HeapArray))
                        self.HeapArray[parent], self.HeapArray[child] = self.HeapArray[child], self.HeapArray[parent]
                        parent = child
                    else:
                        break
                elif self.HeapArray[2*parent+1]:
                        if self.HeapArray[parent] <= self.HeapArray[2*parent+1]:
                            child = self.HeapArray.index(self.HeapArray[2*parent+1], parent+1, len(self.HeapArray))
                            self.HeapArray[parent], self.HeapArray[child] = self.HeapArray[child], self.HeapArray[parent]
                            parent = child
                        else:
                            break
                elif self.HeapArray[2*parent+2]:
                        if self.HeapArray[parent] <= self.HeapArray[2*parent+2]:
                            child = self.HeapArray.index(self.HeapArray[2*parent+2], parent+1, len(self.HeapArray))
                            self.HeapArray[parent], self.HeapArray[child] = self.HeapArray[child], self.HeapArray[parent]
                            parent = child
                        else:
                            break 
                else:
                    break
            return max_elem

    def Add(self, key):

        if None in self.HeapArray:
            child = self.HeapArray.index(None)
            self.HeapArray[child] = key
            while child > 0:
                parent = int((child-1)/2)
                if self.HeapArray[child] > self.HeapArray[parent]:
                    self.HeapArray[child], self.HeapArray[parent] = self.HeapArray[parent], self.HeapArray[child]
                    child = parent
                else:
                    break
            return True
        else:
            return False

            
class HeapSort:
    
    def __init__(self, array):

        if len(array) == 0:
            raise Exception('array is empty!')
        depth = 0
        while sum([2**i for i in range(depth+1)]) < len(array):
            depth += 1
        self.HeapObject = Heap()
        self.HeapObject.HeapArray = [None] * sum([2**i for i in range(depth+1)])
        for elem in array:
            self.HeapObject.Add(elem)
        
    def GetNextMax(self):

        if self.HeapObject.HeapArray[0] is not None:
            return self.HeapObject.GetMax()
        else:
            return -1 

class ksort:
    
    def __init__(self):

        self.items = [None] * 799
        
    def index(self, s):

        sample = 'abcdefgh'
        if len(s) == 3 and s[0] in sample and int(s[1:]) in range(100):
            if s[1:] != '00':
                index = 100*sample.index(s[0]) + int(s[1:])
            else:
                index = 100*sample.index(s[0])
            return index    
        else:
            return -1
        
    def add(self, s):

        index = self.index(s)
        if index != -1:
            self.items.insert(index, s)
            return True
        else:
            return False


class BinarySearch:

    def __init__(self, array):

        self.array = array
        self.Left = 0
        self.Right = len(self.array)-1
        self.value = 0
        
    def Step(self, N):

        index = (self.Left+self.Right)//2 
        if self.array[index] is N:
            self.value = 1
        elif self.Left == self.Right:
            self.value = -1
        elif self.Left == self.Right-1:
                self.Left += 1  
        else:
            if self.array[index] > N:
                self.Right = index-1
            else:
                self.Left = index+1
                             
    def GetResult(self):

        return self.value

        
class BinarySearch:

    def __init__(self, array):

        self.array = array
        self.Left = 0
        self.Right = len(self.array)-1
        self.value = 0
        self.index = 0
        
    def Step(self, N):     

        self.index = (self.Left+self.Right)//2 
        if self.array[self.index] > N:
            self.Right = self.index-1
        elif self.array[self.index] < N:
            self.Left = self.index+1
        else:
            self.value = 1
        if self.Left == self.Right:
            if self.array[self.Left] == N:
                self.value = 1
            else:
                self.value = -1
        elif self.Left+1 == self.Right:
            if self.array[self.Left] == N or self.array[self.Right] == N:
                self.value = 1
            else:
                self.value = -1

    def GetResult(self):

        return self.value


class BinarySearch:

    def __init__(self, array):

        self.array = array
        self.Left = 0
        self.Right = len(self.array)-1
        self.value = 0
        self.index = 0
        
    def Step(self, N):

        self.index = (self.Left+self.Right)//2
        if self.array[self.index] > N:
            self.Right = self.index-1
        elif self.array[self.index] < N:
            self.Left = self.index+1
        else:
            self.value = 1
        if self.Left == self.Right:
            if self.array[self.Left] == N:
                self.value = 1
            else:
                self.value = -1
        elif self.Left+1 == self.Right:
            if self.array[self.Left] == N or self.array[self.Right] == N:
                self.value = 1
            else:
                self.value = -1

    def GetResult(self):

        return self.value
        
def GallopingSearch(array, N):

    instance = BinarySearch(array)
    inc = 0
    while array[instance.index] <= N:
        inc += 1
        instance.index = 2**inc-2
        if instance.index < len(instance.array):
            if instance.array[instance.index] == N:
                return True
        else:
            instance.index = len(instance.array)-1
            break
    instance.Right = instance.index
    instance.Left = int(2**(inc-1)-1)        
    while instance.Left != instance.Right:
        instance.Step(N)
        if instance.GetResult() == 1:
            return True
    return False

array = []
for i in range(5):
    array.append(i)
print(array)
for i in range(-1, 6):
    print(i, GallopingSearch(array, i))
